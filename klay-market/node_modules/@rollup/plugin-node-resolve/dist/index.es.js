import { dirname, resolve, extname, normalize, sep } from 'path';
import builtinList from 'builtin-modules';
import isModule from 'is-module';
import fs, { realpathSync } from 'fs';
import { promisify } from 'util';
import { createFilter } from '@rollup/pluginutils';
import resolveModule from 'resolve';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

const exists = promisify(fs.exists);
const readFile = promisify(fs.readFile);
const realpath = promisify(fs.realpath);
const stat = promisify(fs.stat);

const onError = error => {
  if (error.code === 'ENOENT') {
    return false;
  }

  throw error;
};

const makeCache = fn => {
  const cache = new Map();

  const wrapped =
  /*#__PURE__*/
  function () {
    var _ref = _asyncToGenerator(function* (param, done) {
      if (cache.has(param) === false) {
        cache.set(param, fn(param).catch(err => {
          cache.delete(param);
          throw err;
        }));
      }

      try {
        const result = cache.get(param);
        const value = yield result;
        return done(null, value);
      } catch (error) {
        return done(error);
      }
    });

    return function wrapped(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();

  wrapped.clear = () => cache.clear();

  return wrapped;
};

const isDirCached = makeCache(
/*#__PURE__*/
function () {
  var _ref2 = _asyncToGenerator(function* (file) {
    try {
      const stats = yield stat(file);
      return stats.isDirectory();
    } catch (error) {
      return onError(error);
    }
  });

  return function (_x3) {
    return _ref2.apply(this, arguments);
  };
}());
const isFileCached = makeCache(
/*#__PURE__*/
function () {
  var _ref3 = _asyncToGenerator(function* (file) {
    try {
      const stats = yield stat(file);
      return stats.isFile();
    } catch (error) {
      return onError(error);
    }
  });

  return function (_x4) {
    return _ref3.apply(this, arguments);
  };
}());
const readCachedFile = makeCache(readFile);

const resolveId = promisify(resolveModule); // returns the imported package name for bare module imports

function getPackageName(id) {
  if (id.startsWith('.') || id.startsWith('/')) {
    return null;
  }

  const split = id.split('/'); // @my-scope/my-package/foo.js -> @my-scope/my-package
  // @my-scope/my-package -> @my-scope/my-package

  if (split[0][0] === '@') {
    return `${split[0]}/${split[1]}`;
  } // my-package/foo.js -> my-package
  // my-package -> my-package


  return split[0];
}
function getMainFields(options) {
  let mainFields;

  if (options.mainFields) {
    mainFields = options.mainFields;
  } else {
    mainFields = ['module', 'main'];
  }

  if (options.browser && mainFields.indexOf('browser') === -1) {
    return ['browser'].concat(mainFields);
  }

  if (!mainFields.length) {
    throw new Error('Please ensure at least one `mainFields` value is specified');
  }

  return mainFields;
}
function getPackageInfo(options) {
  const cache = options.cache,
        extensions = options.extensions,
        pkg = options.pkg,
        mainFields = options.mainFields,
        preserveSymlinks = options.preserveSymlinks,
        useBrowserOverrides = options.useBrowserOverrides;
  let pkgPath = options.pkgPath;

  if (cache.has(pkgPath)) {
    return 